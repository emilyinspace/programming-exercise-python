#!/usr/bin/env python3

import argparse
import re
import sys
import os

"""
TODO 1. cleanup of comments, pep compliant, quiet option, check everything
"""

# Checks if string is valid regex
def is_valid_regex(regex_str):
    try:
        re.compile(regex_str)
        is_valid = True
    except re.error:
        is_valid = False

    return (is_valid)


# Parse command-line arguments
def parse_cmd_args():

    parser = argparse.ArgumentParser(prog="mini-grep",
                                     description="Minimal version of grep",
                                     add_help=True)

    # Optional argument to make the script quieter. False by default
    parser.add_argument("-q", dest="quiet", help="(q)uiet only outputs lines\
                         but omits the matching line numbers",
                        action='store_true', required=False)

    # Required regex pattern argument
    parser.add_argument("-e", dest="PATTERN",
                        help="valid regex pattern to search for", type=str,
                        required=True)

    # FILE variadic argument
    parser.add_argument("FILE", action='store', type=str, nargs='*')
    args = parser.parse_args()

    return args


def enum_and_match(file, regex_pattern, stdin_ln_list, quiet_flag):

    # If file was given
    if file:
        enum_iter = open(file)
        filename = file
        # Iterate through the file's lines, print regex-matching ones
        #for i, line in enumerate(open(file)):
            #for match in re.finditer(regex_pattern, line):
                #print('ln %s in %s: %s' % (i+1, file, match.group()))

    # Else if stdin input was given
    elif stdin_ln_list:
        enum_iter = stdin_ln_list
        filename = "stdin"
        #for i, line in enumerate(stdin_ln_list):
            #for match in re.finditer(regex_pattern, line):
                #print('ln %s in %s: %s' % (i+1, "stdin", match.group()))


    for i, line in enumerate(enum_iter):
        for match in re.finditer(regex_pattern, line):
            if quiet_flag:
                print('%s' % match.group())
            else:
                print('%s: %s' % (i+1,  match.group()))

    if file:
        #print("~~~closing file", file)
        enum_iter.close()


# Find regex pattern matches in requested files
def find_file_matches(file_list, regex_pattern, quiet_flag):

    # Iterate through the received file list
    for file in file_list:

        # If file given, isn't a file, exit fatally
        if not os.path.isfile(file):
            sys.exit("ERROR: " + file + " is not a file.")

        # Iterate through the file's lines, print regex-matching ones
        enum_and_match(file, regex_pattern, None, quiet_flag)
        #for i, line in enumerate(open(file)):
            #for match in re.finditer(regex_pattern, line):
                #print('ln %s in %s: %s' % (i+1, file, match.group()))


# Find regex pattern matches from stdin
# TODO: input_str should be input_list or sth
def find_stdin_matches(stdin_ln_list, regex_pattern, quiet_flag):
    print("~~~~~~~~~~~~~~~~~~~")
    enum_and_match(None, regex_pattern, stdin_ln_list, quiet_flag)
    #for i, line in enumerate(input_str):
        #for match in re.finditer(regex_pattern, line):
            #print('ln %s in %s: %s' % (i+1, "stdin", match.group()))
    print("~~~~~~~~~~~~~~~~~~~")

# Main function
def main():
    args = parse_cmd_args()
    #print("----start----")
    #print("quiet = ", args.quiet)
    #print("pattern = ", args.PATTERN)
    #print("FILE = ", args.FILE)
    #print("----end------")

    # Check if received regex pattern is valid
    if not is_valid_regex(args.PATTERN):
        sys.exit("ERROR: regex pattern " + args.PATTERN + " is invalid!")

    # If args.FILE is an empty list, we will parse entries from stdin
    if not len(args.FILE):

        # TODO: here we put the stdin stuff
        print("Enter your text below:")
        stdin_ln_list = sys.stdin.readlines()
        find_stdin_matches(stdin_ln_list, args.PATTERN, args.quiet)
        #find_file_matches(files_list, args.PATTERN)


    # Else, file arguments were given, so we parse them for regex matches
    else:
        find_file_matches(args.FILE, args.PATTERN, args.quiet)


# If the script is run directly, it will be the main program
if __name__ == "__main__":
    main()
