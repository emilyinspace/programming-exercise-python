#!/usr/bin/env python3

import argparse
import re
import sys
import os


# Checks if string is valid regex
def is_valid_regex(regex_str):
    try:
        re.compile(regex_str)
        is_valid = True
    except re.error:
        is_valid = False

    return (is_valid)


# Parse command-line arguments
def parse_cmd_args():

    parser = argparse.ArgumentParser(prog="mini-grep",
                                     description="Minimal version of grep",
                                     add_help=True)

    # Optional argument to make the script quieter. False by default
    parser.add_argument("-q", dest="quiet", help="(q)uiet only outputs lines\
                         but omits the matching line numbers",
                        action='store_true', required=False)

    # Required regex pattern argument
    parser.add_argument("-e", dest="PATTERN",
                        help="valid regex pattern to search for", type=str,
                        required=True)

    # FILE variadic argument
    parser.add_argument("FILE", action='store', type=str, nargs='*')
    args = parser.parse_args()

    return args


def enum_and_match(file, regex_pattern, stdin_ln_list, quiet_flag):

    # If file was given
    if file:
        enum_iter = open(file)

    # Else if stdin input was given
    elif stdin_ln_list:
        enum_iter = stdin_ln_list

    # Enumerate the file or stdin input
    for i, line in enumerate(enum_iter):

        # For each matching line, we print it
        for match in re.finditer(regex_pattern, line):

            # If quiet output was requested, we print only the matching line
            if quiet_flag:
                print('%s' % match.group())

            # If quiet output wasn't requested,
            # we print matching line number and line
            else:
                print('%s: %s' % (i+1,  match.group()))

    # If file was given, we close it
    if file:
        enum_iter.close()


# Find regex pattern matches in requested files
def find_file_matches(file_list, regex_pattern, quiet_flag):

    # Iterate through the received file list
    for file in file_list:

        # If file given, isn't a file, exit fatally
        if not os.path.isfile(file):
            sys.exit("ERROR: " + file + " is not a file.")

        # Iterate through the file's lines, print regex-matching ones
        enum_and_match(file, regex_pattern, None, quiet_flag)


# Find regex pattern matches from stdin
def find_stdin_matches(stdin_ln_list, regex_pattern, quiet_flag):
    print("~~~~~~~~~~~~~~~~~~~")
    enum_and_match(None, regex_pattern, stdin_ln_list, quiet_flag)
    print("~~~~~~~~~~~~~~~~~~~")


# Main function
def main():
    args = parse_cmd_args()

    # Check if received regex pattern is valid
    if not is_valid_regex(args.PATTERN):
        sys.exit("ERROR: regex pattern " + args.PATTERN + " is invalid!")

    # If args.FILE is an empty list, we will parse entries from stdin
    if not len(args.FILE):

        print("Enter your text below:")

        # Read stdin input as list variable
        stdin_ln_list = sys.stdin.readlines()

        # Find matches
        find_stdin_matches(stdin_ln_list, args.PATTERN, args.quiet)

    # Else, file arguments were given, so we parse them for regex matches
    else:
        find_file_matches(args.FILE, args.PATTERN, args.quiet)


# If the script is run directly, it will be the main program
if __name__ == "__main__":
    main()
